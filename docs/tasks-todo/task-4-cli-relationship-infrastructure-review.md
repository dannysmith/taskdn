# Task 4: Relationship Infrastructure & Review

**Work Directory:** `tdn-cli/`

**Depends on:** Task 3 (List Command)

## Overview

This is a review checkpoint after implementing basic show and list functionality. Before proceeding to the context command (which fundamentally requires relationship traversal), we pause to:

1. Review the current codebase architecture
2. Refactor as needed based on review findings
3. Design and implement relationship infrastructure (resolving wikilinks to connect tasks, projects & areas)

## Why This Checkpoint Exists

We have now implemented enough working features that we can identify architectural improvements. The current implementations were built incrementally with little attention to shared abstractions. Specifically:

- Three nearly identical Rust parser modules (task.rs, project.rs, area.rs)
- Repeated patterns that could be consolidated
- Relationship traversal is needed for Task 5 (context command)

**Critical for Task 5:** The context command (`context area "Work"`) must find all projects with `area: [[Work]]` and all tasks belonging to those projects. Without proper infrastructure, this becomes O(tasks × projects) file reads per query.

---

## Current Codebase Summary

### Rust Core (`crates/core/src/`)

| File | Purpose | Lines | Key Types |
|------|---------|-------|-----------|
| `lib.rs` | Module exports, NAPI macro | ~10 | - |
| `task.rs` | Task parsing | ~230 | `TaskStatus`, `TaskFrontmatter`, `Task`, `parse_task_file()` |
| `project.rs` | Project parsing | ~200 | `ProjectStatus`, `ProjectFrontmatter`, `Project`, `parse_project_file()` |
| `area.rs` | Area parsing | ~165 | `AreaStatus`, `AreaFrontmatter`, `Area`, `parse_area_file()` |
| `vault.rs` | Directory scanning, fuzzy search | ~440 | `VaultConfig`, `scan_*()`, `find_*_by_title()` |

### TypeScript Layer (`src/`)

| Directory | Purpose | Key Files |
|-----------|---------|-----------|
| `commands/` | CLI command implementations | `list.ts` (445 lines), `show.ts`, `add.ts` (stub), `context.ts` (stub) |
| `output/` | Output formatters | `human.ts`, `ai.ts`, `json.ts`, `types.ts` |
| `errors/` | Error types and formatting | `types.ts`, `format.ts` |
| `config/` | Vault configuration | `index.ts` |
| `lib/` | Shared utilities | `entity-lookup.ts` |

### NAPI Bindings (`bindings/`)

Auto-generated by NAPI-RS. Contains TypeScript type definitions for all Rust exports.

---

## Phases

### Phase 1: Review

Review the current codebase critically, focusing on patterns that can reduce duplication and improve reliability. The goal is to identify concrete refactoring opportunities before implementing relationship infrastructure.

#### 1.1 Rust Parser Architecture Review

**Files to examine:**
- `crates/core/src/task.rs`
- `crates/core/src/project.rs`
- `crates/core/src/area.rs`
- `crates/core/src/vault.rs`

**Current pattern (repeated 3 times):**
```rust
// 1. Status enum
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "kebab-case")]
#[napi(string_enum)]
pub enum EntityStatus { ... }

// 2. Private frontmatter struct
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
struct EntityFrontmatter { ... }

// 3. Public NAPI struct
#[derive(Debug, Clone)]
#[napi(object)]
pub struct Entity { ... }

// 4. Parse function
#[napi]
pub fn parse_entity_file(file_path: String) -> Result<Entity> {
    // Check exists → read file → parse frontmatter → build struct
}
```

**Questions to answer:**

1. **Is the Frontmatter/Entity separation appropriate?**
   - Current: TaskFrontmatter (internal) → Task (NAPI)
   - This allows frontmatter field names (kebab-case) to differ from NAPI field names (camelCase)
   - Worth keeping? Or could we use serde aliases?

2. **Should there be a shared Entity trait or parsing infrastructure?**
   - All three parsers have identical structure: read file → gray_matter parse → validate → build struct
   - Options:
     - **Trait-based:** `trait Entity { fn from_frontmatter(...) }` with generic parse function
     - **Macro-based:** `define_entity!` macro generating the boilerplate
     - **Keep separate:** Entities diverge enough that sharing is premature
   - Consider: Task 6 (write operations) will need round-trip fidelity. Does shared infrastructure help or hinder?

3. **Is error handling consistent?**
   - All parsers use `napi::Result<T>` with `Error::new(Status::GenericFailure, message)`
   - Error messages follow pattern: "File not found:", "Failed to read file:", "Failed to parse frontmatter:", "No frontmatter found"
   - Is this granular enough? Does TypeScript layer need to distinguish error types?

4. **Are there obvious DRY violations?**
   - Test helper functions (`create_temp_task`, `create_temp_project`, `create_temp_area`) are identical
   - Could extract to shared test module

5. **What about vault.rs?**
   - `scan_directory<T, F>` is already generic with function pointers
   - `find_*_by_title` functions are nearly identical - could be generalized

#### 1.2 TypeScript Layer Review

**Files to examine:**
- `src/commands/list.ts` (largest command, 445 lines)
- `src/output/*.ts` (formatter implementations)
- `src/errors/*.ts` (error handling)
- `src/lib/entity-lookup.ts`

**Questions to answer:**

1. **Is the Formatter interface pattern working well?**
   - Current: discriminated union `FormattableResult` with switch/case in each formatter
   - Does this scale as we add more result types?

2. **Are there repeated patterns in list.ts?**
   - Multiple status/filter checks with similar structure
   - Date handling utilities - should these move to a shared module?

3. **Error handling flow:**
   - Rust throws → JS catches → pattern match on message string → create CliError
   - Is matching on error message fragile? Should Rust return structured error types?

4. **Entity lookup pattern:**
   - `entity-lookup.ts` provides `LookupResult<T>` with path detection
   - Will this work for relationship resolution?

#### 1.3 Review Deliverable

At the end of Phase 1, produce a summary of findings:
- List of identified refactoring opportunities (prioritized)
- Recommendation for each: do now, defer, or skip
- Any blocking issues for Phase 3

**Not in scope for Phase 1:** Actually doing any refactoring. Just identify and document.

---

### Phase 2: Refactor

Based on Phase 1 findings, implement agreed-upon refactors. Prioritize changes that:
1. Reduce complexity for Phase 3 (relationship infrastructure)
2. Set up patterns needed for Task 6 (write operations)
3. Have clear, bounded scope

**Likely candidates (to be confirmed in Phase 1):**

- Extract shared test utilities in Rust
- Consider generic/trait-based parsing if appropriate
- Improve error type handling if needed
- Consolidate date utilities in TypeScript

**After refactoring:**
- Run `bun run fix` and `bun run check`
- Ensure all existing tests pass
- Update any documentation affected by changes

---

### Phase 3: Relationship Infrastructure

Implement infrastructure for resolving wikilink references between entities.

#### 3.1 WikiLink Parsing Utility

Create a utility to extract names from wikilink syntax. Per S1 spec Section 1 (Terminology):

**WikiLink formats:**
- Basic: `[[Page Name]]`
- With display text: `[[Page Name|Display Text]]`
- With heading: `[[Page Name#Heading]]`
- Combined: `[[Page Name#Heading|Display Text]]`

**Implementation (`crates/core/src/wikilink.rs`):**

```rust
/// Extract the target name from a wikilink reference.
/// Returns None if the input is not a wikilink (e.g., a path).
///
/// # Examples
/// - `[[Simple Name]]` → Some("Simple Name")
/// - `[[Name|Alias]]` → Some("Name")
/// - `[[Name#Heading]]` → Some("Name")
/// - `[[Name#Heading|Alias]]` → Some("Name")
/// - `./relative/path.md` → None
/// - `path.md` → None
pub fn extract_wikilink_name(reference: &str) -> Option<&str>
```

**Tests:**
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn basic_wikilink() {
        assert_eq!(extract_wikilink_name("[[Simple Name]]"), Some("Simple Name"));
    }

    #[test]
    fn wikilink_with_alias() {
        assert_eq!(extract_wikilink_name("[[Name|Alias]]"), Some("Name"));
    }

    #[test]
    fn wikilink_with_heading() {
        assert_eq!(extract_wikilink_name("[[Name#Heading]]"), Some("Name"));
    }

    #[test]
    fn wikilink_with_heading_and_alias() {
        assert_eq!(extract_wikilink_name("[[Name#Heading|Alias]]"), Some("Name"));
    }

    #[test]
    fn relative_path_is_not_wikilink() {
        assert_eq!(extract_wikilink_name("./projects/file.md"), None);
    }

    #[test]
    fn filename_is_not_wikilink() {
        assert_eq!(extract_wikilink_name("file.md"), None);
    }

    #[test]
    fn empty_wikilink() {
        assert_eq!(extract_wikilink_name("[[]]"), None);
    }

    #[test]
    fn whitespace_handling() {
        assert_eq!(extract_wikilink_name("[[ Spaced Name ]]"), Some("Spaced Name"));
    }
}
```

#### 3.2 Vault Index Design

Design an in-memory index for efficient relationship queries. The index is built once per CLI invocation (no persistence).

**Proposed structure (`crates/core/src/vault_index.rs`):**

```rust
use std::collections::HashMap;
use crate::task::Task;
use crate::project::Project;
use crate::area::Area;
use crate::vault::VaultConfig;

/// In-memory index of vault entities with relationship mappings.
/// Built once per CLI invocation for efficient relationship traversal.
pub struct VaultIndex {
    // All entities
    pub tasks: Vec<Task>,
    pub projects: Vec<Project>,
    pub areas: Vec<Area>,

    // Name-to-index lookup (for resolving wikilinks)
    // Keys are lowercase for case-insensitive matching
    project_by_name: HashMap<String, usize>,
    area_by_name: HashMap<String, usize>,

    // Relationship maps (index → indices)
    tasks_by_project: HashMap<usize, Vec<usize>>,  // project idx → task indices
    tasks_by_area: HashMap<usize, Vec<usize>>,     // area idx → task indices (direct assignment)
    projects_by_area: HashMap<usize, Vec<usize>>,  // area idx → project indices
}
```

**Key methods:**

```rust
impl VaultIndex {
    /// Build index by scanning all directories.
    /// Files that fail to parse are skipped (matches scan_* behavior).
    pub fn build(config: &VaultConfig) -> Self;

    /// Get all tasks directly assigned to an area.
    pub fn tasks_in_area_direct(&self, area_idx: usize) -> Vec<&Task>;

    /// Get all tasks in an area (direct + via projects).
    pub fn tasks_in_area(&self, area_idx: usize) -> Vec<&Task>;

    /// Get all tasks in a project.
    pub fn tasks_in_project(&self, project_idx: usize) -> Vec<&Task>;

    /// Get all projects in an area.
    pub fn projects_in_area(&self, area_idx: usize) -> Vec<&Project>;

    /// Get parent project for a task (if any).
    pub fn project_for_task(&self, task_idx: usize) -> Option<&Project>;

    /// Get parent area for a task (direct or via project).
    pub fn area_for_task(&self, task_idx: usize) -> Option<&Area>;

    /// Get parent area for a project (if any).
    pub fn area_for_project(&self, project_idx: usize) -> Option<&Area>;

    /// Find area by name (case-insensitive).
    pub fn find_area(&self, name: &str) -> Option<(usize, &Area)>;

    /// Find project by name (case-insensitive).
    pub fn find_project(&self, name: &str) -> Option<(usize, &Project)>;
}
```

**Build process:**

1. Scan tasks directory → parse all tasks → store in `tasks`
2. Scan projects directory → parse all projects → store in `projects`
3. Scan areas directory → parse all areas → store in `areas`
4. Build `project_by_name` map (lowercase title → index)
5. Build `area_by_name` map (lowercase title → index)
6. For each task with `project` field:
   - Extract wikilink name
   - Look up project index
   - Add to `tasks_by_project[project_idx]`
7. For each task with `area` field:
   - Extract wikilink name
   - Look up area index
   - Add to `tasks_by_area[area_idx]`
8. For each project with `area` field:
   - Extract wikilink name
   - Look up area index
   - Add to `projects_by_area[area_idx]`

**Unresolvable references:** Store as warnings but don't fail. This supports a future `doctor` command for detecting broken references.

#### 3.3 NAPI Exposure

Expose the index to TypeScript. **Recommended approach:** Single function returning full index.

```rust
/// Build and return a complete vault index.
/// This is the primary entry point for relationship-aware queries.
#[napi]
pub fn build_vault_index(config: VaultConfig) -> VaultIndex;
```

The TypeScript layer receives the full index and can perform any needed queries. This is simpler than exposing individual query functions via NAPI, and the CLI is short-lived so memory is not a concern.

**NAPI struct export:**

```rust
#[derive(Debug, Clone)]
#[napi(object)]
pub struct VaultIndex {
    pub tasks: Vec<Task>,
    pub projects: Vec<Project>,
    pub areas: Vec<Area>,
    // Note: HashMaps don't export well to NAPI
    // Either expose query methods, or serialize relationship data differently
}
```

**Alternative if HashMap export is problematic:**

```rust
#[napi(object)]
pub struct VaultIndex {
    pub tasks: Vec<Task>,
    pub projects: Vec<Project>,
    pub areas: Vec<Area>,
    // Relationship data as arrays of tuples
    pub task_project_links: Vec<TaskProjectLink>,  // (task_idx, project_idx)
    pub task_area_links: Vec<TaskAreaLink>,        // (task_idx, area_idx)
    pub project_area_links: Vec<ProjectAreaLink>,  // (project_idx, area_idx)
}
```

The TypeScript layer would then build lookup maps from these arrays.

#### 3.4 Update List Command

Update the `--area` filter in the list command to use proper relationship traversal.

**Current behavior:** Only finds tasks with direct `area: [[X]]` assignment
**New behavior:** Finds tasks in area directly OR via their project

```typescript
// Before (in list.ts)
if (options.area) {
  const areaQuery = options.area.toLowerCase();
  tasks = tasks.filter((task) => {
    if (!task.area) return false;
    return task.area.toLowerCase().includes(areaQuery);
  });
}

// After
if (options.area) {
  const index = buildVaultIndex(config);
  const areaMatch = index.areas.find(a =>
    a.title.toLowerCase().includes(options.area.toLowerCase())
  );
  if (areaMatch) {
    const areaIdx = index.areas.indexOf(areaMatch);
    const tasksInArea = getTasksInArea(index, areaIdx); // includes via projects
    tasks = tasks.filter(t => tasksInArea.some(ta => ta.path === t.path));
  } else {
    tasks = []; // No matching area
  }
}
```

**Note:** This may require building the index even when not using `--area`. Consider lazy index building or a separate code path.

#### 3.5 Testing Strategy

**Rust unit tests for wikilink parsing:**
- All format variations
- Edge cases (empty, whitespace, malformed)

**Rust unit tests for VaultIndex:**
- Build from empty directories
- Build with orphan entities (tasks without project/area)
- Build with unresolvable references
- Relationship queries return correct results

**E2E tests for updated list --area:**
- Task with direct area assignment found
- Task with project in area found (indirect)
- Task with both direct and indirect (deduplicated)
- Works with all output modes

---

## Verification Checklist

### Phase 1
- [ ] Reviewed all Rust parser files
- [ ] Reviewed TypeScript command layer
- [ ] Documented refactoring opportunities
- [ ] Prioritized recommendations

### Phase 2
- [ ] Implemented agreed refactors
- [ ] All tests pass
- [ ] `bun run check` passes

### Phase 3
- [ ] `extract_wikilink_name()` implemented with tests
- [ ] `VaultIndex` struct implemented
- [ ] `build_vault_index()` exported via NAPI
- [ ] `--area` filter uses relationship traversal
- [ ] E2E tests for relationship-aware queries
- [ ] `tdn-cli/docs/cli-progress.md` updated

---

## Notes

- Keep the index simple for now - optimize later if needed
- Case-insensitive matching for wikilink resolution (matches existing fuzzy search behavior)
- The index is rebuilt for each CLI invocation (no persistence)
- This sets up Task 5 (context command) for success
- Consider how relationship infrastructure supports Task 6 (write operations) - e.g., validating references

## Relevant Specifications

- **S1-core.md Section 1:** WikiLink terminology and format
- **S1-core.md Section 3.4:** Task `projects` and `area` fields
- **S1-core.md Section 4.4:** Project `area` field
- **cli-tech.md:** Architecture principles (stateless core, path as identifier)

## Dependencies for Future Tasks

- **Task 5 (Context Command):** Requires VaultIndex for `context area "Work"` and `context project "Q1"`
- **Task 6 (Write Operations):** May use relationship infrastructure for reference validation
