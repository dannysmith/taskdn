# Task 4: Relationship Infrastructure & Review

**Work Directory:** `tdn-cli/`

**Depends on:** Task 3 (List Command)

## Overview

This is a review checkpoint after implementing basic show and list functionality. Before proceeding to the context command (which fundamentally requires relationship traversal), we pause to:

1. Review the current codebase architecture
2. Refactor as needed based on review findings
3. Design and implement relationship infrastructure (resolving wikilinks to connect tasks, projects & areas)

## Why This Checkpoint Exists

We have now implemented enough working features that we can identify architectural improvements. The current implementations were built incrementally with little attention to shared abstractions. Specifically:

- Three nearly identical Rust parser modules (task.rs, project.rs, area.rs)
- Repeated patterns that could be consolidated
- Relationship traversal is needed for Task 5 (context command)

**Critical for Task 5:** The context command (`context area "Work"`) must find all projects with `area: [[Work]]` and all tasks belonging to those projects. Without proper infrastructure, this becomes O(tasks × projects) file reads per query.

---

## Current Codebase Summary

### Rust Core (`crates/core/src/`)

| File         | Purpose                          | Lines | Key Types                                                                |
| ------------ | -------------------------------- | ----- | ------------------------------------------------------------------------ |
| `lib.rs`     | Module exports, NAPI macro       | ~10   | -                                                                        |
| `task.rs`    | Task parsing                     | ~230  | `TaskStatus`, `TaskFrontmatter`, `Task`, `parse_task_file()`             |
| `project.rs` | Project parsing                  | ~200  | `ProjectStatus`, `ProjectFrontmatter`, `Project`, `parse_project_file()` |
| `area.rs`    | Area parsing                     | ~165  | `AreaStatus`, `AreaFrontmatter`, `Area`, `parse_area_file()`             |
| `vault.rs`   | Directory scanning, fuzzy search | ~440  | `VaultConfig`, `scan_*()`, `find_*_by_title()`                           |

### TypeScript Layer (`src/`)

| Directory   | Purpose                     | Key Files                                                              |
| ----------- | --------------------------- | ---------------------------------------------------------------------- |
| `commands/` | CLI command implementations | `list.ts` (445 lines), `show.ts`, `add.ts` (stub), `context.ts` (stub) |
| `output/`   | Output formatters           | `human.ts`, `ai.ts`, `json.ts`, `types.ts`                             |
| `errors/`   | Error types and formatting  | `types.ts`, `format.ts`                                                |
| `config/`   | Vault configuration         | `index.ts`                                                             |
| `lib/`      | Shared utilities            | `entity-lookup.ts`                                                     |

### NAPI Bindings (`bindings/`)

Auto-generated by NAPI-RS. Contains TypeScript type definitions for all Rust exports.

---

## Phases

### Phase 1: Review

Review the current codebase critically, focusing on patterns that can reduce duplication and improve reliability. The goal is to identify concrete refactoring opportunities before implementing relationship infrastructure.

#### 1.1 Rust Parser Architecture Review

**Files to examine:**

- `crates/core/src/task.rs`
- `crates/core/src/project.rs`
- `crates/core/src/area.rs`
- `crates/core/src/vault.rs`

**Current pattern (repeated 3 times):**

```rust
// 1. Status enum
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "kebab-case")]
#[napi(string_enum)]
pub enum EntityStatus { ... }

// 2. Private frontmatter struct
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
struct EntityFrontmatter { ... }

// 3. Public NAPI struct
#[derive(Debug, Clone)]
#[napi(object)]
pub struct Entity { ... }

// 4. Parse function
#[napi]
pub fn parse_entity_file(file_path: String) -> Result<Entity> {
    // Check exists → read file → parse frontmatter → build struct
}
```

**Questions to answer:**

1. **Is the Frontmatter/Entity separation appropriate?**

   - Current: TaskFrontmatter (internal) → Task (NAPI)
   - This allows frontmatter field names (kebab-case) to differ from NAPI field names (camelCase)
   - Worth keeping? Or could we use serde aliases?

2. **Should there be a shared Entity trait or parsing infrastructure?**

   - All three parsers have identical structure: read file → gray_matter parse → validate → build struct
   - Options:
     - **Trait-based:** `trait Entity { fn from_frontmatter(...) }` with generic parse function
     - **Macro-based:** `define_entity!` macro generating the boilerplate
     - **Keep separate:** Entities diverge enough that sharing is premature
   - Consider: Task 6 (write operations) will need round-trip fidelity. Does shared infrastructure help or hinder?

3. **Is error handling consistent?**

   - All parsers use `napi::Result<T>` with `Error::new(Status::GenericFailure, message)`
   - Error messages follow pattern: "File not found:", "Failed to read file:", "Failed to parse frontmatter:", "No frontmatter found"
   - Is this granular enough? Does TypeScript layer need to distinguish error types?

4. **Are there obvious DRY violations?**

   - Test helper functions (`create_temp_task`, `create_temp_project`, `create_temp_area`) are identical
   - Could extract to shared test module

5. **What about vault.rs?**
   - `scan_directory<T, F>` is already generic with function pointers
   - `find_*_by_title` functions are nearly identical - could be generalized

#### 1.2 TypeScript Layer Review

**Files to examine:**

- `src/commands/list.ts` (largest command, 445 lines)
- `src/output/*.ts` (formatter implementations)
- `src/errors/*.ts` (error handling)
- `src/lib/entity-lookup.ts`

**Questions to answer:**

1. **Is the Formatter interface pattern working well?**

   - Current: discriminated union `FormattableResult` with switch/case in each formatter
   - Does this scale as we add more result types?

2. **Are there repeated patterns in list.ts?**

   - Multiple status/filter checks with similar structure
   - Date handling utilities - should these move to a shared module?

3. **Error handling flow:**

   - Rust throws → JS catches → pattern match on message string → create CliError
   - Is matching on error message fragile? Should Rust return structured error types?

4. **Entity lookup pattern:**
   - `entity-lookup.ts` provides `LookupResult<T>` with path detection
   - Will this work for relationship resolution?

#### 1.3 Review Deliverable

At the end of Phase 1, produce a summary of findings:

- List of identified refactoring opportunities (prioritized)
- Recommendation for each: do now, defer, or skip
- Any blocking issues for Phase 3

**Not in scope for Phase 1:** Actually doing any refactoring. Just identify and document.

---

### Phase 1.1 Findings (Completed)

**Summary:** The Rust core is well-structured for read operations. The duplication across entity modules is tolerable. Minimal refactoring recommended.

#### Key Decisions

1. **Frontmatter/Entity separation: Keep as-is**
   - The separation (e.g., `TaskFrontmatter` → `Task`) is appropriate
   - YAML uses kebab-case; TypeScript expects camelCase
   - Shape differs: `projects: [...]` array → `project: Option<String>` singular
   - Serde aliases wouldn't handle all transformations

2. **Shared parsing infrastructure: Skip**
   - Trait-based or macro-based approaches add complexity without proportional benefit
   - Only 3 entity types with non-trivial field mappings
   - Current "explicit" code is more readable than abstraction machinery

3. **Error handling: Defer to later task**
   - Current string-based errors work but are fragile
   - Structured error types would help Task 6, but not blocking
   - Can be improved incrementally

4. **Round-trip fidelity for Task 6: Critical finding**
   - Current parsers discard information (unknown fields, date format, reference format)
   - This is fine for read operations—they're "parsed views"
   - Write operations need a different approach: manipulate raw YAML, not typed structs
   - See cli-tech.md "Read vs Write Separation" section for architecture

#### Refactoring Recommendations

| Priority | Item | Decision |
|----------|------|----------|
| **High** | Extract shared Rust test utilities | Do in Phase 2 |
| **Low** | Structured error types | Defer to Task 7 |
| **Skip** | Generic parsing trait | Not needed for 3 types |
| **Skip** | Generalize `find_*_by_title` | Only 24 lines saved |

#### Blocking Issues for Phase 3

**None.** Current architecture supports VaultIndex and wikilink parsing as additive changes.

---

### Phase 1.2 Findings (Completed)

**Summary:** TypeScript layer is well-structured with clean type safety. The Formatter pattern works well at current scale. Minor opportunities for extraction, but no urgent refactoring needed.

#### Files Reviewed

| File | Lines | Purpose |
|------|-------|---------|
| `src/commands/list.ts` | 446 | List command with all filters/sorting |
| `src/commands/show.ts` | 104 | Show single entity |
| `src/output/types.ts` | 88 | Types, Formatter interface, `toKebabCase()` |
| `src/output/human.ts` | 342 | Human-readable colored output |
| `src/output/ai.ts` | 274 | Structured markdown for LLMs |
| `src/output/json.ts` | 149 | JSON output |
| `src/errors/types.ts` | 247 | Comprehensive error type system |
| `src/errors/format.ts` | 330 | Error formatting for all modes |
| `src/lib/entity-lookup.ts` | 211 | Unified lookup with `LookupResult<T>` |
| `src/config/index.ts` | 105 | Config loading with precedence |

#### Key Observations

1. **Formatter Interface Pattern: Working Well**
   - Discriminated union `FormattableResult` with switch/case in each formatter
   - Currently 6 result types—adding more requires updating all 3 formatters
   - Acceptable at current scale; revisit if we exceed ~12 result types

2. **Error System: Comprehensive**
   - Well-designed discriminated union (`CliError`) with specific error types
   - `createError` helper functions provide clean API
   - All error types have human/AI/JSON formatting
   - Exit codes mapped per error type

3. **Entity Lookup: Good Abstraction**
   - `LookupResult<T>` with types: `'exact' | 'single' | 'multiple' | 'none'`
   - Handles both path queries and title queries
   - **Ready for relationship resolution**—can use same pattern for wikilink lookups

4. **Type Safety: Excellent**
   - No `any` types found
   - Proper discriminated unions throughout
   - Type guards provided (`isCliError`)
   - Clean interface with Rust bindings via `@bindings`

5. **Error Handling Flow**
   - Only `show.ts` currently catches/formats errors
   - Pattern: catch → detect type from message string → create CliError → format
   - String matching on Rust errors is fragile but functional
   - Will improve if Rust structured errors added (Task 7)

6. **Date Utilities in list.ts**
   - 5 date functions: `getToday()`, `formatDate()`, `getTomorrow()`, `getEndOfWeek()`, `getStartOfWeek()`
   - Currently only used in list.ts
   - Will be needed for `today` command (Task 5) and write operations (Task 6)
   - **Candidate for extraction** when implementing Task 5

7. **Known TODO**
   - `show.ts:22-29`: `detectEntityType()` uses path heuristics instead of config dirs
   - Comment notes this should use vault config when available
   - Not blocking; can fix when enhancing show command

#### Refactoring Recommendations

| Priority | Item | Decision |
|----------|------|----------|
| **Medium** | Extract date utilities to `src/lib/date.ts` | Do when implementing Task 5 `today` command |
| **Low** | Fix `detectEntityType()` to use config | Defer—works correctly for now |
| **Skip** | Abstract formatter pattern further | Current switch/case is clear |
| **Skip** | Extract status constants/colors | Not reused enough to justify |

#### TypeScript Layer Summary for Phase 3

**Good to proceed.** The existing infrastructure supports relationship features:
- `entity-lookup.ts` pattern can resolve wikilink references
- Error types include `REFERENCE_ERROR` for broken references
- Formatter pattern can accommodate new result types (context command output)

---

### Phase 2: Refactor

Based on Phase 1 findings, implement the following refactors:

#### 2.1 Extract Shared Rust Test Utilities

Each parser module has an identical helper:
```rust
fn create_temp_task(content: &str) -> NamedTempFile {
    let mut file = NamedTempFile::new().unwrap();
    file.write_all(content.as_bytes()).unwrap();
    file
}
```

Extract to a shared test module in `lib.rs` or `test_utils.rs`:
```rust
#[cfg(test)]
pub mod test_utils {
    use std::io::Write;
    use tempfile::NamedTempFile;

    pub fn create_temp_file(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::new().unwrap();
        file.write_all(content.as_bytes()).unwrap();
        file
    }
}
```

Update `task.rs`, `project.rs`, `area.rs` to use `crate::test_utils::create_temp_file`.

#### 2.2 Remove Unused Dependency

Cargo.toml includes `thiserror = "2"` but it's not used. Either:
- Remove it (if not planning to use structured errors soon)
- Keep it (if planning to add structured errors in Task 7)

**Decision:** Keep it—we'll likely use it for structured errors in Task 7.

#### 2.3 After Refactoring

- Run `bun run fix` and `bun run check`
- Ensure all existing tests pass
- Verify bindings regenerate correctly

---

### Phase 3: Relationship Infrastructure

Implement infrastructure for resolving wikilink references between entities.

#### 3.1 WikiLink Parsing Utility

Create a utility to extract names from wikilink syntax. Per S1 spec Section 1 (Terminology):

**WikiLink formats:**

- Basic: `[[Page Name]]`
- With display text: `[[Page Name|Display Text]]`
- With heading: `[[Page Name#Heading]]`
- Combined: `[[Page Name#Heading|Display Text]]`

**Implementation (`crates/core/src/wikilink.rs`):**

```rust
/// Extract the target name from a wikilink reference.
/// Returns None if the input is not a wikilink (e.g., a path).
///
/// # Examples
/// - `[[Simple Name]]` → Some("Simple Name")
/// - `[[Name|Alias]]` → Some("Name")
/// - `[[Name#Heading]]` → Some("Name")
/// - `[[Name#Heading|Alias]]` → Some("Name")
/// - `./relative/path.md` → None
/// - `path.md` → None
pub fn extract_wikilink_name(reference: &str) -> Option<&str>
```

**Tests:**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn basic_wikilink() {
        assert_eq!(extract_wikilink_name("[[Simple Name]]"), Some("Simple Name"));
    }

    #[test]
    fn wikilink_with_alias() {
        assert_eq!(extract_wikilink_name("[[Name|Alias]]"), Some("Name"));
    }

    #[test]
    fn wikilink_with_heading() {
        assert_eq!(extract_wikilink_name("[[Name#Heading]]"), Some("Name"));
    }

    #[test]
    fn wikilink_with_heading_and_alias() {
        assert_eq!(extract_wikilink_name("[[Name#Heading|Alias]]"), Some("Name"));
    }

    #[test]
    fn relative_path_is_not_wikilink() {
        assert_eq!(extract_wikilink_name("./projects/file.md"), None);
    }

    #[test]
    fn filename_is_not_wikilink() {
        assert_eq!(extract_wikilink_name("file.md"), None);
    }

    #[test]
    fn empty_wikilink() {
        assert_eq!(extract_wikilink_name("[[]]"), None);
    }

    #[test]
    fn whitespace_handling() {
        assert_eq!(extract_wikilink_name("[[ Spaced Name ]]"), Some("Spaced Name"));
    }
}
```

#### 3.2 Vault Index Design

Design an in-memory index for efficient relationship queries. The index is built once per CLI invocation (no persistence).

**Proposed structure (`crates/core/src/vault_index.rs`):**

```rust
use std::collections::HashMap;
use crate::task::Task;
use crate::project::Project;
use crate::area::Area;
use crate::vault::VaultConfig;

/// In-memory index of vault entities with relationship mappings.
/// Built once per CLI invocation for efficient relationship traversal.
pub struct VaultIndex {
    // All entities
    pub tasks: Vec<Task>,
    pub projects: Vec<Project>,
    pub areas: Vec<Area>,

    // Name-to-index lookup (for resolving wikilinks)
    // Keys are lowercase for case-insensitive matching
    project_by_name: HashMap<String, usize>,
    area_by_name: HashMap<String, usize>,

    // Relationship maps (index → indices)
    tasks_by_project: HashMap<usize, Vec<usize>>,  // project idx → task indices
    tasks_by_area: HashMap<usize, Vec<usize>>,     // area idx → task indices (direct assignment)
    projects_by_area: HashMap<usize, Vec<usize>>,  // area idx → project indices
}
```

**Key methods:**

```rust
impl VaultIndex {
    /// Build index by scanning all directories.
    /// Files that fail to parse are skipped (matches scan_* behavior).
    pub fn build(config: &VaultConfig) -> Self;

    /// Get all tasks directly assigned to an area.
    pub fn tasks_in_area_direct(&self, area_idx: usize) -> Vec<&Task>;

    /// Get all tasks in an area (direct + via projects).
    pub fn tasks_in_area(&self, area_idx: usize) -> Vec<&Task>;

    /// Get all tasks in a project.
    pub fn tasks_in_project(&self, project_idx: usize) -> Vec<&Task>;

    /// Get all projects in an area.
    pub fn projects_in_area(&self, area_idx: usize) -> Vec<&Project>;

    /// Get parent project for a task (if any).
    pub fn project_for_task(&self, task_idx: usize) -> Option<&Project>;

    /// Get parent area for a task (direct or via project).
    pub fn area_for_task(&self, task_idx: usize) -> Option<&Area>;

    /// Get parent area for a project (if any).
    pub fn area_for_project(&self, project_idx: usize) -> Option<&Area>;

    /// Find area by name (case-insensitive).
    pub fn find_area(&self, name: &str) -> Option<(usize, &Area)>;

    /// Find project by name (case-insensitive).
    pub fn find_project(&self, name: &str) -> Option<(usize, &Project)>;
}
```

**Build process:**

1. Scan tasks directory → parse all tasks → store in `tasks`
2. Scan projects directory → parse all projects → store in `projects`
3. Scan areas directory → parse all areas → store in `areas`
4. Build `project_by_name` map (lowercase title → index)
5. Build `area_by_name` map (lowercase title → index)
6. For each task with `project` field:
   - Extract wikilink name
   - Look up project index
   - Add to `tasks_by_project[project_idx]`
7. For each task with `area` field:
   - Extract wikilink name
   - Look up area index
   - Add to `tasks_by_area[area_idx]`
8. For each project with `area` field:
   - Extract wikilink name
   - Look up area index
   - Add to `projects_by_area[area_idx]`

**Unresolvable references:** Store as warnings but don't fail. This supports a future `doctor` command for detecting broken references.

#### 3.3 NAPI Exposure

Expose the index to TypeScript. **Recommended approach:** Single function returning full index.

```rust
/// Build and return a complete vault index.
/// This is the primary entry point for relationship-aware queries.
#[napi]
pub fn build_vault_index(config: VaultConfig) -> VaultIndex;
```

The TypeScript layer receives the full index and can perform any needed queries. This is simpler than exposing individual query functions via NAPI, and the CLI is short-lived so memory is not a concern.

**NAPI struct export:**

```rust
#[derive(Debug, Clone)]
#[napi(object)]
pub struct VaultIndex {
    pub tasks: Vec<Task>,
    pub projects: Vec<Project>,
    pub areas: Vec<Area>,
    // Note: HashMaps don't export well to NAPI
    // Either expose query methods, or serialize relationship data differently
}
```

**Alternative if HashMap export is problematic:**

```rust
#[napi(object)]
pub struct VaultIndex {
    pub tasks: Vec<Task>,
    pub projects: Vec<Project>,
    pub areas: Vec<Area>,
    // Relationship data as arrays of tuples
    pub task_project_links: Vec<TaskProjectLink>,  // (task_idx, project_idx)
    pub task_area_links: Vec<TaskAreaLink>,        // (task_idx, area_idx)
    pub project_area_links: Vec<ProjectAreaLink>,  // (project_idx, area_idx)
}
```

The TypeScript layer would then build lookup maps from these arrays.

#### 3.4 Update List Command

Update the `--area` filter in the list command to use proper relationship traversal.

**Current behavior:** Only finds tasks with direct `area: [[X]]` assignment
**New behavior:** Finds tasks in area directly OR via their project

```typescript
// Before (in list.ts)
if (options.area) {
  const areaQuery = options.area.toLowerCase()
  tasks = tasks.filter((task) => {
    if (!task.area) return false
    return task.area.toLowerCase().includes(areaQuery)
  })
}

// After
if (options.area) {
  const index = buildVaultIndex(config)
  const areaMatch = index.areas.find((a) =>
    a.title.toLowerCase().includes(options.area.toLowerCase())
  )
  if (areaMatch) {
    const areaIdx = index.areas.indexOf(areaMatch)
    const tasksInArea = getTasksInArea(index, areaIdx) // includes via projects
    tasks = tasks.filter((t) => tasksInArea.some((ta) => ta.path === t.path))
  } else {
    tasks = [] // No matching area
  }
}
```

**Note:** This may require building the index even when not using `--area`. Consider lazy index building or a separate code path.

#### 3.5 Testing Strategy

**Rust unit tests for wikilink parsing:**

- All format variations
- Edge cases (empty, whitespace, malformed)

**Rust unit tests for VaultIndex:**

- Build from empty directories
- Build with orphan entities (tasks without project/area)
- Build with unresolvable references
- Relationship queries return correct results

**E2E tests for updated list --area:**

- Task with direct area assignment found
- Task with project in area found (indirect)
- Task with both direct and indirect (deduplicated)
- Works with all output modes

---

## Verification Checklist

### Phase 1

- [x] Reviewed all Rust parser files (1.1 complete)
- [x] Reviewed TypeScript command layer (1.2 complete)
- [x] Documented refactoring opportunities
- [x] Prioritized recommendations

### Phase 2

- [ ] Extracted shared Rust test utilities
- [ ] All tests pass
- [ ] `bun run check` passes

### Phase 3

- [ ] `extract_wikilink_name()` implemented with tests
- [ ] `VaultIndex` struct implemented
- [ ] `build_vault_index()` exported via NAPI
- [ ] `--area` filter uses relationship traversal
- [ ] E2E tests for relationship-aware queries
- [ ] `tdn-cli/docs/cli-progress.md` updated

---

## Notes

- Keep the index simple for now - optimize later if needed
- Case-insensitive matching for wikilink resolution (matches existing fuzzy search behavior)
- The index is rebuilt for each CLI invocation (no persistence)
- This sets up Task 5 (context command) for success
- Consider how relationship infrastructure supports Task 6 (write operations) - e.g., validating references

## Relevant Specifications

- **S1-core.md Section 1:** WikiLink terminology and format
- **S1-core.md Section 3.4:** Task `projects` and `area` fields
- **S1-core.md Section 4.4:** Project `area` field
- **cli-tech.md:** Architecture principles (stateless core, path as identifier)

## Dependencies for Future Tasks

- **Task 5 (Context Command):** Requires VaultIndex for `context area "Work"` and `context project "Q1"`
- **Task 6 (Write Operations):** May use relationship infrastructure for reference validation
