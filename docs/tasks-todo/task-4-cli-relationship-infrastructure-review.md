# Task 4: Relationship Infrastructure & Review

**Work Directory:** `tdn-cli/`

**Depends on:** Task 3 (List Command)

## Overview

This is a review checkpoint after implementing basic show and list functionality. Before proceeding to the context command (which fundamentally requires relationship traversal), we pause to:

1. Review the current codebase architecture
2. Refactor as needed based on review findings
3. Design and implement relationship infrastructure (resolving wikilinks to connect tasks, projects & areas)

## Why This Checkpoint Exists

We have now implemented enough working features that we can identify architectural improvements. The current implementations were built incrementally with little attention to shared abstractions. Specifically:

- Three nearly identical Rust parser modules (task.rs, project.rs, area.rs)
- Repeated patterns that could be consolidated
- Relationship traversal is needed for Task 5 (context command)

**Critical for Task 5:** The context command (`context area "Work"`) must find all projects with `area: [[Work]]` and all tasks belonging to those projects. Without proper infrastructure, this becomes O(tasks × projects) file reads per query.

---

## Current Codebase Summary

### Rust Core (`crates/core/src/`)

| File         | Purpose                          | Lines | Key Types                                                                |
| ------------ | -------------------------------- | ----- | ------------------------------------------------------------------------ |
| `lib.rs`     | Module exports, NAPI macro       | ~10   | -                                                                        |
| `task.rs`    | Task parsing                     | ~230  | `TaskStatus`, `TaskFrontmatter`, `Task`, `parse_task_file()`             |
| `project.rs` | Project parsing                  | ~200  | `ProjectStatus`, `ProjectFrontmatter`, `Project`, `parse_project_file()` |
| `area.rs`    | Area parsing                     | ~165  | `AreaStatus`, `AreaFrontmatter`, `Area`, `parse_area_file()`             |
| `vault.rs`   | Directory scanning, fuzzy search | ~440  | `VaultConfig`, `scan_*()`, `find_*_by_title()`                           |

### TypeScript Layer (`src/`)

| Directory   | Purpose                     | Key Files                                                              |
| ----------- | --------------------------- | ---------------------------------------------------------------------- |
| `commands/` | CLI command implementations | `list.ts` (445 lines), `show.ts`, `add.ts` (stub), `context.ts` (stub) |
| `output/`   | Output formatters           | `human.ts`, `ai.ts`, `json.ts`, `types.ts`                             |
| `errors/`   | Error types and formatting  | `types.ts`, `format.ts`                                                |
| `config/`   | Vault configuration         | `index.ts`                                                             |
| `lib/`      | Shared utilities            | `entity-lookup.ts`                                                     |

### NAPI Bindings (`bindings/`)

Auto-generated by NAPI-RS. Contains TypeScript type definitions for all Rust exports.

---

## Phases

### Phase 1: Review

Review the current codebase critically, focusing on patterns that can reduce duplication and improve reliability. The goal is to identify concrete refactoring opportunities before implementing relationship infrastructure.

#### 1.1 Rust Parser Architecture Review

**Files to examine:**

- `crates/core/src/task.rs`
- `crates/core/src/project.rs`
- `crates/core/src/area.rs`
- `crates/core/src/vault.rs`

**Current pattern (repeated 3 times):**

```rust
// 1. Status enum
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "kebab-case")]
#[napi(string_enum)]
pub enum EntityStatus { ... }

// 2. Private frontmatter struct
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
struct EntityFrontmatter { ... }

// 3. Public NAPI struct
#[derive(Debug, Clone)]
#[napi(object)]
pub struct Entity { ... }

// 4. Parse function
#[napi]
pub fn parse_entity_file(file_path: String) -> Result<Entity> {
    // Check exists → read file → parse frontmatter → build struct
}
```

**Questions to answer:**

1. **Is the Frontmatter/Entity separation appropriate?**

   - Current: TaskFrontmatter (internal) → Task (NAPI)
   - This allows frontmatter field names (kebab-case) to differ from NAPI field names (camelCase)
   - Worth keeping? Or could we use serde aliases?

2. **Should there be a shared Entity trait or parsing infrastructure?**

   - All three parsers have identical structure: read file → gray_matter parse → validate → build struct
   - Options:
     - **Trait-based:** `trait Entity { fn from_frontmatter(...) }` with generic parse function
     - **Macro-based:** `define_entity!` macro generating the boilerplate
     - **Keep separate:** Entities diverge enough that sharing is premature
   - Consider: Task 6 (write operations) will need round-trip fidelity. Does shared infrastructure help or hinder?

3. **Is error handling consistent?**

   - All parsers use `napi::Result<T>` with `Error::new(Status::GenericFailure, message)`
   - Error messages follow pattern: "File not found:", "Failed to read file:", "Failed to parse frontmatter:", "No frontmatter found"
   - Is this granular enough? Does TypeScript layer need to distinguish error types?

4. **Are there obvious DRY violations?**

   - Test helper functions (`create_temp_task`, `create_temp_project`, `create_temp_area`) are identical
   - Could extract to shared test module

5. **What about vault.rs?**
   - `scan_directory<T, F>` is already generic with function pointers
   - `find_*_by_title` functions are nearly identical - could be generalized

#### 1.2 TypeScript Layer Review

**Files to examine:**

- `src/commands/list.ts` (largest command, 445 lines)
- `src/output/*.ts` (formatter implementations)
- `src/errors/*.ts` (error handling)
- `src/lib/entity-lookup.ts`

**Questions to answer:**

1. **Is the Formatter interface pattern working well?**

   - Current: discriminated union `FormattableResult` with switch/case in each formatter
   - Does this scale as we add more result types?

2. **Are there repeated patterns in list.ts?**

   - Multiple status/filter checks with similar structure
   - Date handling utilities - should these move to a shared module?

3. **Error handling flow:**

   - Rust throws → JS catches → pattern match on message string → create CliError
   - Is matching on error message fragile? Should Rust return structured error types?

4. **Entity lookup pattern:**
   - `entity-lookup.ts` provides `LookupResult<T>` with path detection
   - Will this work for relationship resolution?

#### 1.3 Review Deliverable

At the end of Phase 1, produce a summary of findings:

- List of identified refactoring opportunities (prioritized)
- Recommendation for each: do now, defer, or skip
- Any blocking issues for Phase 3

**Not in scope for Phase 1:** Actually doing any refactoring. Just identify and document.

---

### Phase 1.1 Findings (Completed)

**Summary:** The Rust core is well-structured for read operations. The duplication across entity modules is tolerable. Minimal refactoring recommended.

#### Key Decisions

1. **Frontmatter/Entity separation: Keep as-is**
   - The separation (e.g., `TaskFrontmatter` → `Task`) is appropriate
   - YAML uses kebab-case; TypeScript expects camelCase
   - Shape differs: `projects: [...]` array → `project: Option<String>` singular
   - Serde aliases wouldn't handle all transformations

2. **Shared parsing infrastructure: Skip**
   - Trait-based or macro-based approaches add complexity without proportional benefit
   - Only 3 entity types with non-trivial field mappings
   - Current "explicit" code is more readable than abstraction machinery

3. **Error handling: Defer to later task**
   - Current string-based errors work but are fragile
   - Structured error types would help Task 6, but not blocking
   - Can be improved incrementally

4. **Round-trip fidelity for Task 6: Critical finding**
   - Current parsers discard information (unknown fields, date format, reference format)
   - This is fine for read operations—they're "parsed views"
   - Write operations need a different approach: manipulate raw YAML, not typed structs
   - See cli-tech.md "Read vs Write Separation" section for architecture

#### Refactoring Recommendations

| Priority | Item | Decision |
|----------|------|----------|
| **High** | Extract shared Rust test utilities | Do in Phase 2 |
| **Low** | Structured error types | Defer to Task 7 |
| **Skip** | Generic parsing trait | Not needed for 3 types |
| **Skip** | Generalize `find_*_by_title` | Only 24 lines saved |

#### Blocking Issues for Phase 3

**None.** Current architecture supports VaultIndex and wikilink parsing as additive changes.

---

### Phase 1.2 Findings (Completed)

**Summary:** TypeScript layer is well-structured with clean type safety. The Formatter pattern works well at current scale. Minor opportunities for extraction, but no urgent refactoring needed.

#### Files Reviewed

| File | Lines | Purpose |
|------|-------|---------|
| `src/commands/list.ts` | 446 | List command with all filters/sorting |
| `src/commands/show.ts` | 104 | Show single entity |
| `src/output/types.ts` | 88 | Types, Formatter interface, `toKebabCase()` |
| `src/output/human.ts` | 342 | Human-readable colored output |
| `src/output/ai.ts` | 274 | Structured markdown for LLMs |
| `src/output/json.ts` | 149 | JSON output |
| `src/errors/types.ts` | 247 | Comprehensive error type system |
| `src/errors/format.ts` | 330 | Error formatting for all modes |
| `src/lib/entity-lookup.ts` | 211 | Unified lookup with `LookupResult<T>` |
| `src/config/index.ts` | 105 | Config loading with precedence |

#### Key Observations

1. **Formatter Interface Pattern: Working Well**
   - Discriminated union `FormattableResult` with switch/case in each formatter
   - Currently 6 result types—adding more requires updating all 3 formatters
   - Acceptable at current scale; revisit if we exceed ~12 result types

2. **Error System: Comprehensive**
   - Well-designed discriminated union (`CliError`) with specific error types
   - `createError` helper functions provide clean API
   - All error types have human/AI/JSON formatting
   - Exit codes mapped per error type

3. **Entity Lookup: Good Abstraction**
   - `LookupResult<T>` with types: `'exact' | 'single' | 'multiple' | 'none'`
   - Handles both path queries and title queries
   - **Ready for relationship resolution**—can use same pattern for wikilink lookups

4. **Type Safety: Excellent**
   - No `any` types found
   - Proper discriminated unions throughout
   - Type guards provided (`isCliError`)
   - Clean interface with Rust bindings via `@bindings`

5. **Error Handling Flow**
   - Only `show.ts` currently catches/formats errors
   - Pattern: catch → detect type from message string → create CliError → format
   - String matching on Rust errors is fragile but functional
   - Will improve if Rust structured errors added (Task 7)

6. **Date Utilities in list.ts**
   - 5 date functions: `getToday()`, `formatDate()`, `getTomorrow()`, `getEndOfWeek()`, `getStartOfWeek()`
   - Currently only used in list.ts
   - Will be needed for `today` command (Task 5) and write operations (Task 6)
   - **Candidate for extraction** when implementing Task 5

7. **Known TODO**
   - `show.ts:22-29`: `detectEntityType()` uses path heuristics instead of config dirs
   - Comment notes this should use vault config when available
   - Not blocking; can fix when enhancing show command

#### Refactoring Recommendations

| Priority | Item | Decision |
|----------|------|----------|
| **Medium** | Extract date utilities to `src/lib/date.ts` | Do when implementing Task 5 `today` command |
| **Low** | Fix `detectEntityType()` to use config | Defer—works correctly for now |
| **Skip** | Abstract formatter pattern further | Current switch/case is clear |
| **Skip** | Extract status constants/colors | Not reused enough to justify |

#### TypeScript Layer Summary for Phase 3

**Good to proceed.** The existing infrastructure supports relationship features:
- `entity-lookup.ts` pattern can resolve wikilink references
- Error types include `REFERENCE_ERROR` for broken references
- Formatter pattern can accommodate new result types (context command output)

---

### Phase 2: Refactor

Based on Phase 1 findings, implement the following refactors:

#### 2.1 Extract Shared Rust Test Utilities

Each parser module has an identical helper:
```rust
fn create_temp_task(content: &str) -> NamedTempFile {
    let mut file = NamedTempFile::new().unwrap();
    file.write_all(content.as_bytes()).unwrap();
    file
}
```

Extract to a shared test module in `lib.rs` or `test_utils.rs`:
```rust
#[cfg(test)]
pub mod test_utils {
    use std::io::Write;
    use tempfile::NamedTempFile;

    pub fn create_temp_file(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::new().unwrap();
        file.write_all(content.as_bytes()).unwrap();
        file
    }
}
```

Update `task.rs`, `project.rs`, `area.rs` to use `crate::test_utils::create_temp_file`.

#### 2.2 Remove Unused Dependency

Cargo.toml includes `thiserror = "2"` but it's not used. Either:
- Remove it (if not planning to use structured errors soon)
- Keep it (if planning to add structured errors in Task 7)

**Decision:** Keep it—we'll likely use it for structured errors in Task 7.

#### 2.3 After Refactoring

- Run `bun run fix` and `bun run check`
- Ensure all existing tests pass
- Verify bindings regenerate correctly

---

### Phase 3: Relationship Infrastructure

Implement infrastructure for resolving wikilink references between entities.

#### 3.1 WikiLink Parsing Utility

Create a utility to extract names from wikilink syntax. Per S1 spec Section 1 (Terminology):

**WikiLink formats:**

- Basic: `[[Page Name]]`
- With display text: `[[Page Name|Display Text]]`
- With heading: `[[Page Name#Heading]]`
- Combined: `[[Page Name#Heading|Display Text]]`

**Implementation (`crates/core/src/wikilink.rs`):**

```rust
/// Extract the target name from a wikilink reference.
/// Returns None if the input is not a wikilink (e.g., a path).
///
/// # Examples
/// - `[[Simple Name]]` → Some("Simple Name")
/// - `[[Name|Alias]]` → Some("Name")
/// - `[[Name#Heading]]` → Some("Name")
/// - `[[Name#Heading|Alias]]` → Some("Name")
/// - `./relative/path.md` → None
/// - `path.md` → None
pub fn extract_wikilink_name(reference: &str) -> Option<&str>
```

**Tests:**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn basic_wikilink() {
        assert_eq!(extract_wikilink_name("[[Simple Name]]"), Some("Simple Name"));
    }

    #[test]
    fn wikilink_with_alias() {
        assert_eq!(extract_wikilink_name("[[Name|Alias]]"), Some("Name"));
    }

    #[test]
    fn wikilink_with_heading() {
        assert_eq!(extract_wikilink_name("[[Name#Heading]]"), Some("Name"));
    }

    #[test]
    fn wikilink_with_heading_and_alias() {
        assert_eq!(extract_wikilink_name("[[Name#Heading|Alias]]"), Some("Name"));
    }

    #[test]
    fn relative_path_is_not_wikilink() {
        assert_eq!(extract_wikilink_name("./projects/file.md"), None);
    }

    #[test]
    fn filename_is_not_wikilink() {
        assert_eq!(extract_wikilink_name("file.md"), None);
    }

    #[test]
    fn empty_wikilink() {
        assert_eq!(extract_wikilink_name("[[]]"), None);
    }

    #[test]
    fn whitespace_handling() {
        assert_eq!(extract_wikilink_name("[[ Spaced Name ]]"), Some("Spaced Name"));
    }
}
```

---

### Relationship Rules (Reference)

Before designing the implementation, let's document the exact relationship semantics:

**Cardinality:**

| Relationship | Cardinality | Description |
|--------------|-------------|-------------|
| Task → Project | 0..1 | A task can belong to at most one project |
| Project → Tasks | 0..* | A project can have many tasks |
| Project → Area | 0..1 | A project can belong to at most one area |
| Area → Projects | 0..* | An area can have many projects |
| Task → Area (direct) | 0..1 | A task can have a directly assigned area |
| Area → Tasks (direct) | 0..* | An area can have many directly assigned tasks |
| Task → Area (via project) | 0..1 | Derived from task's project's area |
| Area → Tasks (via projects) | 0..* | All tasks belonging to projects in this area |

**Canonical Area for a Task:**
- If task has `area: [[X]]` → use X (direct assignment takes precedence)
- Else if task has `project: [[P]]` and P has `area: [[Y]]` → use Y (inherited from project)
- Else → no area

**Edge Case:** If a task has `area: [[X]]` but its project has `area: [[Y]]` where X ≠ Y:
- The task's canonical area is X (direct takes precedence)
- However, when asking "what tasks are in area Y?", this task should still be included (via its project)
- This situation indicates user error but should be handled gracefully

---

### Phase 3.2 Design Analysis

Before implementing, we evaluated the proposed VaultIndex approach critically.

#### Current Proposal: Full Upfront Index

```rust
pub struct VaultIndex {
    pub tasks: Vec<Task>,
    pub projects: Vec<Project>,
    pub areas: Vec<Area>,
    project_by_name: HashMap<String, usize>,
    area_by_name: HashMap<String, usize>,
    tasks_by_project: HashMap<usize, Vec<usize>>,
    tasks_by_area: HashMap<usize, Vec<usize>>,
    projects_by_area: HashMap<usize, Vec<usize>>,
}
```

Build once per CLI invocation, use for all relationship queries.

#### Performance Analysis

**Index Building Cost:**
- Scan tasks → O(n) file reads for n tasks
- Scan projects → O(m) file reads for m projects
- Scan areas → O(a) file reads for a areas
- Build maps → O(n + m) for wikilink resolution

For vault with 1000 tasks, 50 projects, 10 areas: ~1060 file reads.

**Impact by Operation:**

| Operation | Without Index | With Upfront Index |
|-----------|---------------|-------------------|
| `list` | ~1000 reads | ~1060 reads |
| `list --status ready` | ~1000 reads | ~1060 reads |
| `list --area Work` | ~1000 reads (wrong result!) | ~1060 reads (correct) |
| `show task "Foo"` | 1 read | ~1060 reads |
| `context area "Work"` | N/A | ~1060 reads |

**Key observation:** The upfront index approach penalizes simple operations (like `show`) that don't need relationships.

#### Alternative Approaches Considered

**1. Lazy/On-Demand Index**
- Only build index when relationship queries are needed
- `list` without filters → no index
- `list --area Work` → build index
- Pro: Only pay cost when needed
- Con: Slightly more complex code paths

**2. Query-Specific Functions**
- Expose targeted functions: `get_tasks_in_area(config, name) -> Vec<Task>`
- Implementation internally builds only what it needs
- Pro: Cleaner TypeScript API, implementation can optimize
- Con: May rebuild similar data across calls (but CLI is short-lived)

**3. Partial/Incremental Building**
- For `list --area Work`: find area → find its projects → find those tasks
- Don't load ALL entities
- Pro: Minimal reads
- Con: More complex, multiple passes, still needs all tasks for task filtering

**4. Cached Persistent Index**
- Store index in file, rebuild when files change
- Pro: Fast subsequent runs
- Con: Cache invalidation complexity, violates "stateless core" principle

#### Which Operations Actually Need Relationships?

**Need relationships:**
- `list --area X` (tasks via projects)
- `context area "X"` (area → projects → tasks)
- `context project "X"` (project → tasks)

**Don't need relationships:**
- `list` (just list tasks)
- `list --status ready` (filter by status)
- `show task "X"` (just one task)
- `add task "X"` (create file)
- `edit task "X"` (modify one file)

Most operations don't need relationships.

#### Risks and Considerations

1. **Wikilink resolution is fuzzy:** Case-insensitive matching could cause false positives if two areas have similar names
2. **Broken references:** Tasks may reference non-existent projects/areas - should warn, not fail
3. **Memory for large vaults:** ~500 bytes/task → 5MB for 10K tasks (acceptable)
4. **Partial parse failures:** Some files may fail to parse - index should still work with valid files

#### Recommendation

**Hybrid Approach: Relationship-Aware Query Functions**

Instead of exposing a VaultIndex struct to TypeScript, expose purpose-built query functions:

```rust
// Simple operations - already exist
pub fn scan_tasks(config: VaultConfig) -> Vec<Task>
pub fn scan_projects(config: VaultConfig) -> Vec<Project>

// Relationship-aware queries - new
pub fn get_tasks_in_area(config: VaultConfig, area_name: String) -> TasksInAreaResult {
    // Builds minimal index needed: areas → projects by area → tasks by project
    // Returns tasks + any warnings about broken references
}

pub fn get_tasks_in_project(config: VaultConfig, project_name: String) -> Vec<Task> {
    // Scans tasks, filters by project reference
}

pub fn get_area_context(config: VaultConfig, area_name: String) -> AreaContextResult {
    // Returns area, its projects, all tasks (via projects + direct)
    // Used by context command
}
```

**Benefits:**
1. Simple operations stay fast (no unnecessary index building)
2. Relationship queries pay only their own cost
3. Cleaner API - TypeScript doesn't need to understand index internals
4. Implementation can be optimized without API changes
5. Follows "stateless core" principle

**Trade-off:**
- More functions to implement and maintain
- Can't share index across multiple relationship queries in one command (but this is rare)

#### Decisions Made

1. **API preference:** Expose **composite query functions** rather than VaultIndex struct. TypeScript doesn't need to see the index internals.

2. **Filtering:** Move `--area` and `--project` filtering to Rust (required for correctness). Keep other filters in TypeScript for now (flexible, fast enough).

3. **Index caching:** Use **composite functions** that build what they need internally. Each high-level operation (like `get_area_context`) builds its index once. No need for TypeScript to manage index lifecycle.

4. **Optimization:** `get_projects_in_area` should NOT read task files (only ~50 project files vs ~1000 task files).

5. **Broken wikilinks handling:**
   - Downward queries (`getTasksInArea`): Include all matching tasks; broken refs elsewhere are irrelevant
   - Upward queries (`getAreaForTask`): Return `None` if referenced entity doesn't exist
   - Display commands (`show`): Show entity normally, warn about broken references

---

#### 3.2 Composite Query Functions Design

Instead of exposing a `VaultIndex` struct to TypeScript, we expose purpose-built functions that internally manage the index.

**Key Principle:** Simple operations (like `show task`) should NOT build an index. Only relationship-aware operations build what they need.

**NAPI API (`crates/core/src/vault_index.rs`):**

```rust
// === Existing simple queries (no index needed) ===
pub fn scan_tasks(config: VaultConfig) -> Vec<Task>
pub fn scan_projects(config: VaultConfig) -> Vec<Project>
pub fn scan_areas(config: VaultConfig) -> Vec<Area>

// === New relationship-aware queries ===

/// Result for tasks-in-area query
#[napi(object)]
pub struct TasksInAreaResult {
    pub tasks: Vec<Task>,
    pub warnings: Vec<String>,  // e.g., "Task 'X' references unknown project 'Y'"
}

/// Get tasks in an area (direct + via projects).
/// Reads: areas, projects, tasks. Builds index internally.
#[napi]
pub fn get_tasks_in_area(config: VaultConfig, area_name: String) -> TasksInAreaResult

/// Get projects in an area. Does NOT read task files.
/// Reads: areas, projects only.
#[napi]
pub fn get_projects_in_area(config: VaultConfig, area_name: String) -> Vec<Project>

/// Full context for an area (for context command).
#[napi(object)]
pub struct AreaContextResult {
    pub area: Option<Area>,           // None if area not found
    pub projects: Vec<Project>,       // Projects in this area
    pub tasks: Vec<Task>,             // Tasks via projects + direct
    pub warnings: Vec<String>,
}

#[napi]
pub fn get_area_context(config: VaultConfig, area_name: String) -> AreaContextResult

/// Full context for a project (for context command).
#[napi(object)]
pub struct ProjectContextResult {
    pub project: Option<Project>,     // None if project not found
    pub area: Option<Area>,           // Parent area if any
    pub tasks: Vec<Task>,             // Tasks in this project
    pub warnings: Vec<String>,
}

#[napi]
pub fn get_project_context(config: VaultConfig, project_name: String) -> ProjectContextResult
```

**Internal Implementation:**

The `VaultIndex` struct remains **private** (not exposed via NAPI):

```rust
// Private - not exported
struct VaultIndex {
    tasks: Vec<Task>,
    projects: Vec<Project>,
    areas: Vec<Area>,
    project_by_name: HashMap<String, usize>,
    area_by_name: HashMap<String, usize>,
    tasks_by_project: HashMap<usize, Vec<usize>>,
    tasks_by_area: HashMap<usize, Vec<usize>>,
    projects_by_area: HashMap<usize, Vec<usize>>,
}

impl VaultIndex {
    /// Build full index (reads all entity types)
    fn build(config: &VaultConfig) -> Self { ... }

    /// Build index without tasks (for projects-only queries)
    fn build_without_tasks(config: &VaultConfig) -> Self { ... }
}
```

Each NAPI function internally builds the index it needs:

```rust
#[napi]
pub fn get_projects_in_area(config: VaultConfig, area_name: String) -> Vec<Project> {
    let index = VaultIndex::build_without_tasks(&config);  // Skips task files!
    // Find area, return matching projects
}

#[napi]
pub fn get_area_context(config: VaultConfig, area_name: String) -> AreaContextResult {
    let index = VaultIndex::build(&config);  // Full index
    // Build complete context
}
```

#### 3.3 TypeScript Usage

```typescript
// list.ts - when --area is used
if (options.area) {
  // Call Rust function that handles relationship resolution
  const result = getTasksInArea(config, options.area);
  tasks = result.tasks;
  // Optionally display result.warnings
} else {
  // No relationship needed - use simple scan
  tasks = scanTasks(config);
}

// Apply remaining filters in TypeScript
if (options.status) { ... }
if (options.due) { ... }
```

```typescript
// context.ts
if (entityType === 'area') {
  const context = getAreaContext(config, target);
  if (!context.area) {
    // Handle area not found
  }
  // context.area, context.projects, context.tasks all available
}
```

#### 3.4 Testing Strategy

**Rust unit tests for wikilink parsing:** (Complete - Phase 3.1)

- All format variations
- Edge cases (empty, whitespace, malformed)

**Rust unit tests for VaultIndex (internal):**

- Build from empty directories
- Build with orphan entities (tasks without project/area)
- Build with unresolvable references (should add warnings, not fail)
- Relationship queries return correct results
- `build_without_tasks` doesn't read task files

**Rust unit tests for NAPI functions:**

- `get_tasks_in_area` returns direct + indirect tasks
- `get_tasks_in_area` deduplicates (task with direct area AND project in same area)
- `get_projects_in_area` returns matching projects
- `get_area_context` returns complete context
- `get_project_context` returns project + area + tasks
- All functions handle "not found" gracefully

**E2E tests:**

- `list --area Work` finds tasks via projects
- `list --area Work` finds tasks with direct area assignment
- `context area "Work"` returns area + projects + tasks
- `context project "Q1"` returns project + parent area + tasks
- Works with all output modes

---

## Verification Checklist

### Phase 1

- [x] Reviewed all Rust parser files (1.1 complete)
- [x] Reviewed TypeScript command layer (1.2 complete)
- [x] Documented refactoring opportunities
- [x] Prioritized recommendations

### Phase 2

- [x] Extracted shared Rust test utilities
- [x] All tests pass
- [x] `bun run check` passes

### Phase 3

- [x] `extract_wikilink_name()` implemented with tests
- [ ] Internal `VaultIndex` struct implemented
- [ ] `get_tasks_in_area()` exported via NAPI
- [ ] `get_projects_in_area()` exported via NAPI (optimized - no task files)
- [ ] `get_area_context()` exported via NAPI
- [ ] `get_project_context()` exported via NAPI
- [ ] `list --area` updated to use `get_tasks_in_area()`
- [ ] Unit tests for VaultIndex and NAPI functions
- [ ] E2E tests for relationship-aware queries
- [ ] `tdn-cli/docs/cli-progress.md` updated

---

## Notes

- **VaultIndex is internal** - not exposed to TypeScript; composite functions hide the implementation
- **Lazy building** - simple operations don't build an index; only relationship queries do
- **Optimization** - `get_projects_in_area()` skips reading task files entirely
- **Case-insensitive matching** for wikilink resolution (matches existing fuzzy search behavior)
- **No persistence** - index is rebuilt for each CLI invocation (stateless core principle)
- **Graceful degradation** - broken wikilinks produce warnings, not failures

## Relevant Specifications

- **S1-core.md Section 1:** WikiLink terminology and format
- **S1-core.md Section 3.4:** Task `projects` and `area` fields
- **S1-core.md Section 4.4:** Project `area` field
- **cli-tech.md:** Architecture principles (stateless core, path as identifier)

## Dependencies for Future Tasks

- **Task 5 (Context Command):** Uses `get_area_context()` and `get_project_context()` for hierarchical views
- **Task 6 (Write Operations):** May use relationship infrastructure for reference validation
